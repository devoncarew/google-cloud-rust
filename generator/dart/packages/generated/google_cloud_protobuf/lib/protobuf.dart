// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

/// The Google Cloud client for the Core Protobuf Types.
///
/// Core Protobuf types used by most services.
library;

import 'dart:typed_data';

/// `Any` contains an arbitrary serialized protocol buffer message along with a
/// URL that describes the type of the serialized message.
/// 
/// Protobuf library provides support to pack/unpack Any values in the form
/// of utility functions or additional generated methods of the Any type.
/// 
/// Example 1: Pack and unpack a message in C++.
/// 
///     Foo foo = ...;
///     Any any;
///     any.PackFrom(foo);
///     ...
///     if (any.UnpackTo(&foo)) {
///       ...
///     }
/// 
/// Example 2: Pack and unpack a message in Java.
/// 
///     Foo foo = ...;
///     Any any = Any.pack(foo);
///     ...
///     if (any.is(Foo.class)) {
///       foo = any.unpack(Foo.class);
///     }
///     // or ...
///     if (any.isSameTypeAs(Foo.getDefaultInstance())) {
///       foo = any.unpack(Foo.getDefaultInstance());
///     }
/// 
///  Example 3: Pack and unpack a message in Python.
/// 
///     foo = Foo(...)
///     any = Any()
///     any.Pack(foo)
///     ...
///     if any.Is(Foo.DESCRIPTOR):
///       any.Unpack(foo)
///       ...
/// 
///  Example 4: Pack and unpack a message in Go
/// 
///      foo := &pb.Foo{...}
///      any, err := anypb.New(foo)
///      if err != nil {
///        ...
///      }
///      ...
///      foo := &pb.Foo{}
///      if err := any.UnmarshalTo(foo); err != nil {
///        ...
///      }
/// 
/// The pack methods provided by protobuf library will by default use
/// 'type.googleapis.com/full.type.name' as the type URL and the unpack
/// methods only use the fully qualified type name after the last '/'
/// in the type URL, for example "foo.bar.com/x/y.z" will yield type
/// name "y.z".
/// 
/// JSON
/// ====
/// The JSON representation of an `Any` value uses the regular
/// representation of the deserialized, embedded message, with an
/// additional field `@type` which contains the type URL. Example:
/// 
///     package google.profile;
///     message Person {
///       string first_name = 1;
///       string last_name = 2;
///     }
/// 
///     {
///       "@type": "type.googleapis.com/google.profile.Person",
///       "firstName": <string>,
///       "lastName": <string>
///     }
/// 
/// If the embedded message type is well-known and has a custom JSON
/// representation, that representation will be embedded adding a field
/// `value` which holds the custom JSON in addition to the `@type`
/// field. Example (for message [google.protobuf.Duration][]):
/// 
///     {
///       "@type": "type.googleapis.com/google.protobuf.Duration",
///       "value": "1.212s"
///     }
/// 
class Any {

  /// A URL/resource name that uniquely identifies the type of the serialized
  /// protocol buffer message. This string must contain at least
  /// one "/" character. The last segment of the URL's path must represent
  /// the fully qualified name of the type (as in
  /// `path/google.protobuf.Duration`). The name should be in a canonical form
  /// (e.g., leading "." is not accepted).
  /// 
  /// In practice, teams usually precompile into the binary all types that they
  /// expect it to use in the context of Any. However, for URLs which use the
  /// scheme `http`, `https`, or no scheme, one can optionally set up a type
  /// server that maps type URLs to message definitions as follows:
  /// 
  /// * If no scheme is provided, `https` is assumed.
  /// * An HTTP GET on the URL must yield a [google.protobuf.Type][]
  ///   value in binary format, or produce an error.
  /// * Applications are allowed to cache lookup results based on the
  ///   URL, or have them precompiled into a binary to avoid any
  ///   lookup. Therefore, binary compatibility needs to be preserved
  ///   on changes to types. (Use versioned type names to manage
  ///   breaking changes.)
  /// 
  /// Note: this functionality is not currently available in the official
  /// protobuf release, and it is not used for type URLs beginning with
  /// type.googleapis.com. As of May 2023, there are no widely used type server
  /// implementations and no plans to implement one.
  /// 
  /// Schemes other than `http`, `https` (or the empty scheme) might be
  /// used with implementation specific semantics.
  /// 
  final String? typeUrl;

  /// Must be a valid serialized protocol buffer of the above specified type.
  final Uint8List? value;

  Any({
    this.typeUrl,
    this.value,
  });
}

/// Api is a light-weight descriptor for an API Interface.
/// 
/// Interfaces are also described as "protocol buffer services" in some contexts,
/// such as by the "service" keyword in a .proto file, but they are different
/// from API Services, which represent a concrete implementation of an interface
/// as opposed to simply a description of methods and bindings. They are also
/// sometimes simply referred to as "APIs" in other contexts, such as the name of
/// this message itself. See https://cloud.google.com/apis/design/glossary for
/// detailed terminology.
class Api {

  /// The fully qualified name of this interface, including package name
  /// followed by the interface's simple name.
  final String? name;

  /// The methods of this interface, in unspecified order.
  final List<Method>? methods;

  /// Any metadata attached to the interface.
  final List<Option>? options;

  /// A version string for this interface. If specified, must have the form
  /// `major-version.minor-version`, as in `1.10`. If the minor version is
  /// omitted, it defaults to zero. If the entire version field is empty, the
  /// major version is derived from the package name, as outlined below. If the
  /// field is not empty, the version in the package name will be verified to be
  /// consistent with what is provided here.
  /// 
  /// The versioning schema uses [semantic
  /// versioning](http://semver.org) where the major version number
  /// indicates a breaking change and the minor version an additive,
  /// non-breaking change. Both version numbers are signals to users
  /// what to expect from different versions, and should be carefully
  /// chosen based on the product plan.
  /// 
  /// The major version is also reflected in the package name of the
  /// interface, which must end in `v<major-version>`, as in
  /// `google.feature.v1`. For major versions 0 and 1, the suffix can
  /// be omitted. Zero major versions must only be used for
  /// experimental, non-GA interfaces.
  /// 
  final String? version;

  /// Source context for the protocol buffer service represented by this
  /// message.
  final SourceContext? sourceContext;

  /// Included interfaces. See [Mixin][].
  final List<Mixin>? mixins;

  /// The source syntax of the service.
  final Syntax? syntax;

  Api({
    this.name,
    this.methods,
    this.options,
    this.version,
    this.sourceContext,
    this.mixins,
    this.syntax,
  });
}

/// Method represents a method of an API interface.
class Method {

  /// The simple name of this method.
  final String? name;

  /// A URL of the input message type.
  final String? requestTypeUrl;

  /// If true, the request is streamed.
  final bool? requestStreaming;

  /// The URL of the output message type.
  final String? responseTypeUrl;

  /// If true, the response is streamed.
  final bool? responseStreaming;

  /// Any metadata attached to the method.
  final List<Option>? options;

  /// The source syntax of this method.
  final Syntax? syntax;

  Method({
    this.name,
    this.requestTypeUrl,
    this.requestStreaming,
    this.responseTypeUrl,
    this.responseStreaming,
    this.options,
    this.syntax,
  });
}

/// Declares an API Interface to be included in this interface. The including
/// interface must redeclare all the methods from the included interface, but
/// documentation and options are inherited as follows:
/// 
/// - If after comment and whitespace stripping, the documentation
///   string of the redeclared method is empty, it will be inherited
///   from the original method.
/// 
/// - Each annotation belonging to the service config (http,
///   visibility) which is not set in the redeclared method will be
///   inherited.
/// 
/// - If an http annotation is inherited, the path pattern will be
///   modified as follows. Any version prefix will be replaced by the
///   version of the including interface plus the [root][] path if
///   specified.
/// 
/// Example of a simple mixin:
/// 
///     package google.acl.v1;
///     service AccessControl {
///       // Get the underlying ACL object.
///       rpc GetAcl(GetAclRequest) returns (Acl) {
///         option (google.api.http).get = "/v1/{resource=**}:getAcl";
///       }
///     }
/// 
///     package google.storage.v2;
///     service Storage {
///       rpc GetAcl(GetAclRequest) returns (Acl);
/// 
///       // Get a data record.
///       rpc GetData(GetDataRequest) returns (Data) {
///         option (google.api.http).get = "/v2/{resource=**}";
///       }
///     }
/// 
/// Example of a mixin configuration:
/// 
///     apis:
///     - name: google.storage.v2.Storage
///       mixins:
///       - name: google.acl.v1.AccessControl
/// 
/// The mixin construct implies that all methods in `AccessControl` are
/// also declared with same name and request/response types in
/// `Storage`. A documentation generator or annotation processor will
/// see the effective `Storage.GetAcl` method after inheriting
/// documentation and annotations as follows:
/// 
///     service Storage {
///       // Get the underlying ACL object.
///       rpc GetAcl(GetAclRequest) returns (Acl) {
///         option (google.api.http).get = "/v2/{resource=**}:getAcl";
///       }
///       ...
///     }
/// 
/// Note how the version in the path pattern changed from `v1` to `v2`.
/// 
/// If the `root` field in the mixin is specified, it should be a
/// relative path under which inherited HTTP paths are placed. Example:
/// 
///     apis:
///     - name: google.storage.v2.Storage
///       mixins:
///       - name: google.acl.v1.AccessControl
///         root: acls
/// 
/// This implies the following inherited HTTP annotation:
/// 
///     service Storage {
///       // Get the underlying ACL object.
///       rpc GetAcl(GetAclRequest) returns (Acl) {
///         option (google.api.http).get = "/v2/acls/{resource=**}:getAcl";
///       }
///       ...
///     }
class Mixin {

  /// The fully qualified name of the interface which is included.
  final String? name;

  /// If non-empty specifies a path under which inherited HTTP paths
  /// are rooted.
  final String? root;

  Mixin({
    this.name,
    this.root,
  });
}

/// `FieldMask` represents a set of symbolic field paths, for example:
/// 
///     paths: "f.a"
///     paths: "f.b.d"
/// 
/// Here `f` represents a field in some root message, `a` and `b`
/// fields in the message found in `f`, and `d` a field found in the
/// message in `f.b`.
/// 
/// Field masks are used to specify a subset of fields that should be
/// returned by a get operation or modified by an update operation.
/// Field masks also have a custom JSON encoding (see below).
/// 
/// # Field Masks in Projections
/// 
/// When used in the context of a projection, a response message or
/// sub-message is filtered by the API to only contain those fields as
/// specified in the mask. For example, if the mask in the previous
/// example is applied to a response message as follows:
/// 
///     f {
///       a : 22
///       b {
///         d : 1
///         x : 2
///       }
///       y : 13
///     }
///     z: 8
/// 
/// The result will not contain specific values for fields x,y and z
/// (their value will be set to the default, and omitted in proto text
/// output):
/// 
/// 
///     f {
///       a : 22
///       b {
///         d : 1
///       }
///     }
/// 
/// A repeated field is not allowed except at the last position of a
/// paths string.
/// 
/// If a FieldMask object is not present in a get operation, the
/// operation applies to all fields (as if a FieldMask of all fields
/// had been specified).
/// 
/// Note that a field mask does not necessarily apply to the
/// top-level response message. In case of a REST get operation, the
/// field mask applies directly to the response, but in case of a REST
/// list operation, the mask instead applies to each individual message
/// in the returned resource list. In case of a REST custom method,
/// other definitions may be used. Where the mask applies will be
/// clearly documented together with its declaration in the API.  In
/// any case, the effect on the returned resource/resources is required
/// behavior for APIs.
/// 
/// # Field Masks in Update Operations
/// 
/// A field mask in update operations specifies which fields of the
/// targeted resource are going to be updated. The API is required
/// to only change the values of the fields as specified in the mask
/// and leave the others untouched. If a resource is passed in to
/// describe the updated values, the API ignores the values of all
/// fields not covered by the mask.
/// 
/// If a repeated field is specified for an update operation, new values will
/// be appended to the existing repeated field in the target resource. Note that
/// a repeated field is only allowed in the last position of a `paths` string.
/// 
/// If a sub-message is specified in the last position of the field mask for an
/// update operation, then new value will be merged into the existing sub-message
/// in the target resource.
/// 
/// For example, given the target message:
/// 
///     f {
///       b {
///         d: 1
///         x: 2
///       }
///       c: [1]
///     }
/// 
/// And an update message:
/// 
///     f {
///       b {
///         d: 10
///       }
///       c: [2]
///     }
/// 
/// then if the field mask is:
/// 
///  paths: ["f.b", "f.c"]
/// 
/// then the result will be:
/// 
///     f {
///       b {
///         d: 10
///         x: 2
///       }
///       c: [1, 2]
///     }
/// 
/// An implementation may provide options to override this default behavior for
/// repeated and message fields.
/// 
/// In order to reset a field's value to the default, the field must
/// be in the mask and set to the default value in the provided resource.
/// Hence, in order to reset all fields of a resource, provide a default
/// instance of the resource and set all fields in the mask, or do
/// not provide a mask as described below.
/// 
/// If a field mask is not present on update, the operation applies to
/// all fields (as if a field mask of all fields has been specified).
/// Note that in the presence of schema evolution, this may mean that
/// fields the client does not know and has therefore not filled into
/// the request will be reset to their default. If this is unwanted
/// behavior, a specific service may require a client to always specify
/// a field mask, producing an error if not.
/// 
/// As with get operations, the location of the resource which
/// describes the updated values in the request message depends on the
/// operation kind. In any case, the effect of the field mask is
/// required to be honored by the API.
/// 
/// ## Considerations for HTTP REST
/// 
/// The HTTP kind of an update operation which uses a field mask must
/// be set to PATCH instead of PUT in order to satisfy HTTP semantics
/// (PUT must only be used for full updates).
/// 
/// # JSON Encoding of Field Masks
/// 
/// In JSON, a field mask is encoded as a single string where paths are
/// separated by a comma. Fields name in each path are converted
/// to/from lower-camel naming conventions.
/// 
/// As an example, consider the following message declarations:
/// 
///     message Profile {
///       User user = 1;
///       Photo photo = 2;
///     }
///     message User {
///       string display_name = 1;
///       string address = 2;
///     }
/// 
/// In proto a field mask for `Profile` may look as such:
/// 
///     mask {
///       paths: "user.display_name"
///       paths: "photo"
///     }
/// 
/// In JSON, the same mask is represented as below:
/// 
///     {
///       mask: "user.displayName,photo"
///     }
/// 
/// # Field Masks and Oneof Fields
/// 
/// Field masks treat fields in oneofs just as regular fields. Consider the
/// following message:
/// 
///     message SampleMessage {
///       oneof test_oneof {
///         string name = 4;
///         SubMessage sub_message = 9;
///       }
///     }
/// 
/// The field mask can be:
/// 
///     mask {
///       paths: "name"
///     }
/// 
/// Or:
/// 
///     mask {
///       paths: "sub_message"
///     }
/// 
/// Note that oneof type names ("test_oneof" in this case) cannot be used in
/// paths.
/// 
/// ## Field Mask Verification
/// 
/// The implementation of any API method which has a FieldMask type field in the
/// request should verify the included field paths, and return an
/// `INVALID_ARGUMENT` error if any path is unmappable.
class FieldMask {

  /// The set of field mask paths.
  final List<String>? paths;

  FieldMask({
    this.paths,
  });
}

/// `SourceContext` represents information about the source of a
/// protobuf element, like the file in which it is defined.
class SourceContext {

  /// The path-qualified name of the .proto file that contained the associated
  /// protobuf element.  For example: `"google/protobuf/source_context.proto"`.
  final String? fileName;

  SourceContext({
    this.fileName,
  });
}

/// A protocol buffer message type.
class Type {

  /// The fully qualified message name.
  final String? name;

  /// The list of fields.
  final List<Field>? fields;

  /// The list of types appearing in `oneof` definitions in this type.
  final List<String>? oneofs;

  /// The protocol buffer options.
  final List<Option>? options;

  /// The source context.
  final SourceContext? sourceContext;

  /// The source syntax.
  final Syntax? syntax;

  /// The source edition string, only valid when syntax is SYNTAX_EDITIONS.
  final String? edition;

  Type({
    this.name,
    this.fields,
    this.oneofs,
    this.options,
    this.sourceContext,
    this.syntax,
    this.edition,
  });
}

/// A single field of a message type.
class Field {

  /// The field type.
  final Field$Kind? kind;

  /// The field cardinality.
  final Field$Cardinality? cardinality;

  /// The field number.
  final int? number;

  /// The field name.
  final String? name;

  /// The field type URL, without the scheme, for message or enumeration
  /// types. Example: `"type.googleapis.com/google.protobuf.Timestamp"`.
  final String? typeUrl;

  /// The index of the field type in `Type.oneofs`, for message or enumeration
  /// types. The first type has index 1; zero means the type is not in the list.
  final int? oneofIndex;

  /// Whether to use alternative packed wire representation.
  final bool? packed;

  /// The protocol buffer options.
  final List<Option>? options;

  /// The field JSON name.
  final String? jsonName;

  /// The string value of the default value of this field. Proto2 syntax only.
  final String? defaultValue;

  Field({
    this.kind,
    this.cardinality,
    this.number,
    this.name,
    this.typeUrl,
    this.oneofIndex,
    this.packed,
    this.options,
    this.jsonName,
    this.defaultValue,
  });
}

/// Basic field types.
class Field$Kind {
  /// Field type unknown.
  static const Field$Kind typeUnknown = Field$Kind('TYPE_UNKNOWN');

  /// Field type double.
  static const Field$Kind typeDouble = Field$Kind('TYPE_DOUBLE');

  /// Field type float.
  static const Field$Kind typeFloat = Field$Kind('TYPE_FLOAT');

  /// Field type int64.
  static const Field$Kind typeInt64 = Field$Kind('TYPE_INT64');

  /// Field type uint64.
  static const Field$Kind typeUint64 = Field$Kind('TYPE_UINT64');

  /// Field type int32.
  static const Field$Kind typeInt32 = Field$Kind('TYPE_INT32');

  /// Field type fixed64.
  static const Field$Kind typeFixed64 = Field$Kind('TYPE_FIXED64');

  /// Field type fixed32.
  static const Field$Kind typeFixed32 = Field$Kind('TYPE_FIXED32');

  /// Field type bool.
  static const Field$Kind typeBool = Field$Kind('TYPE_BOOL');

  /// Field type string.
  static const Field$Kind typeString = Field$Kind('TYPE_STRING');

  /// Field type group. Proto2 syntax only, and deprecated.
  static const Field$Kind typeGroup = Field$Kind('TYPE_GROUP');

  /// Field type message.
  static const Field$Kind typeMessage = Field$Kind('TYPE_MESSAGE');

  /// Field type bytes.
  static const Field$Kind typeBytes = Field$Kind('TYPE_BYTES');

  /// Field type uint32.
  static const Field$Kind typeUint32 = Field$Kind('TYPE_UINT32');

  /// Field type enum.
  static const Field$Kind typeEnum = Field$Kind('TYPE_ENUM');

  /// Field type sfixed32.
  static const Field$Kind typeSfixed32 = Field$Kind('TYPE_SFIXED32');

  /// Field type sfixed64.
  static const Field$Kind typeSfixed64 = Field$Kind('TYPE_SFIXED64');

  /// Field type sint32.
  static const Field$Kind typeSint32 = Field$Kind('TYPE_SINT32');

  /// Field type sint64.
  static const Field$Kind typeSint64 = Field$Kind('TYPE_SINT64');

  final String value;

  const Field$Kind(this.value);
}

/// Whether a field is optional, required, or repeated.
class Field$Cardinality {
  /// For fields with unknown cardinality.
  static const Field$Cardinality cardinalityUnknown = Field$Cardinality('CARDINALITY_UNKNOWN');

  /// For optional fields.
  static const Field$Cardinality cardinalityOptional = Field$Cardinality('CARDINALITY_OPTIONAL');

  /// For required fields. Proto2 syntax only.
  static const Field$Cardinality cardinalityRequired = Field$Cardinality('CARDINALITY_REQUIRED');

  /// For repeated fields.
  static const Field$Cardinality cardinalityRepeated = Field$Cardinality('CARDINALITY_REPEATED');

  final String value;

  const Field$Cardinality(this.value);
}

/// Enum type definition.
class Enum {

  /// Enum type name.
  final String? name;

  /// Enum value definitions.
  final List<EnumValue>? enumvalue;

  /// Protocol buffer options.
  final List<Option>? options;

  /// The source context.
  final SourceContext? sourceContext;

  /// The source syntax.
  final Syntax? syntax;

  /// The source edition string, only valid when syntax is SYNTAX_EDITIONS.
  final String? edition;

  Enum({
    this.name,
    this.enumvalue,
    this.options,
    this.sourceContext,
    this.syntax,
    this.edition,
  });
}

/// Enum value definition.
class EnumValue {

  /// Enum value name.
  final String? name;

  /// Enum value number.
  final int? number;

  /// Protocol buffer options.
  final List<Option>? options;

  EnumValue({
    this.name,
    this.number,
    this.options,
  });
}

/// A protocol buffer option, which can be attached to a message, field,
/// enumeration, etc.
class Option {

  /// The option's name. For protobuf built-in options (options defined in
  /// descriptor.proto), this is the short name. For example, `"map_entry"`.
  /// For custom options, it should be the fully-qualified name. For example,
  /// `"google.api.http"`.
  final String? name;

  /// The option's value packed in an Any message. If the value is a primitive,
  /// the corresponding wrapper type defined in google/protobuf/wrappers.proto
  /// should be used. If the value is an enum, it should be stored as an int32
  /// value using the google.protobuf.Int32Value type.
  final Any? value;

  Option({
    this.name,
    this.value,
  });
}

/// The syntax in which a protocol buffer element is defined.
class Syntax {
  /// Syntax `proto2`.
  static const Syntax syntaxProto2 = Syntax('SYNTAX_PROTO2');

  /// Syntax `proto3`.
  static const Syntax syntaxProto3 = Syntax('SYNTAX_PROTO3');

  /// Syntax `editions`.
  static const Syntax syntaxEditions = Syntax('SYNTAX_EDITIONS');

  final String value;

  const Syntax(this.value);
}
